\section{Your mouse is NOT a database!}
Looking through the architecture of Java's interactive collections API, one can immediately notice the amount of interfaces that inherit from \itb \cite{java-iterable-api}. Whilst this \itb only contains a getter for the \itr interface, the subinterfaces of \itb supply more functionality. For example, the \code{Collection} interface introduces functionality for adding, removing, querying and transforming a dataset. It however does not specify the exact behavior of these methods. This is done in more specialized subinterfaces of \code{Collection}. The \code{Set} interface has different behavior on adding an element than the \code{List} or \code{Queue} interfaces. And even within these interfaces the details vary per implementation. A data structure like \code{ArrayList} has the benefit of very efficient random access, but is slower in adding and removing elements in the list \cite{linkedlist-vs-arraylist}. The \code{LinkedList} on the other hand does way better on adding and removing but is not as efficient in doing random access. The \code{Set} interface has also various implementations that provide different behavior. Besides all of that, there is a whole other realm of collection interfaces, specialized in handling concurrency, that contain many more implementations but still all inherit from that same \itb interface.

This inheritance tree of Java's collection API was created the way it is because the authors saw that different circumstances required different data structures that on the one hand all shared the same concept of being able to be iterated over, but on the other hand differed in behavior from other points of view. Even though these data structures shared some commonalities, they had just as many differences in their behavior.

In languages like Scala a similar architecture is used. However, besides the \itb containing a getter for the \itr interface, it also provides and implements many higher-order functions that are able to manipulate the data structure, such as \code{map}, \code{filter}, \code{fold}, \code{reduce} and \code{flatMap}. Other interfaces and classes that inherit from Scala's \itb interface automatically inherit these functions and are expected to behave in such a way that these functions can operate correctly. The various implementations of \itb are allowed to reimplement these functions to make them run more efficient, but are not allowed to alter their behavior.

When we demonstrated the derivation of the \obs collection in \Cref{subsec:derivation}, we argued that, since we only dualized the \textit{interactiveness} of the \ieb to the \textit{reactiveness} of the \obs, all other rules on collections should still apply. This implies that the concept of higher order functions such as \code{map}, \code{flatMap} and \code{fold} on \ieb is still valid, even though these have to be reimplemented to conform to the reactiveness of the \obs collection. Notice that the result of using these functions is not allowed to be different from performing them on any \ieb collection! It is just the implementation that is changed due to the reactiveness.

In contrast to the many subinterfaces and implementations of \itb, a library like Rx, as discussed in \Cref{chap:problem-statement}, has shown only a single interface for (reactive) collections. However, in the previous sections of this chapter we have identified several classes of sources in the light of overflow protection that would greatly benefit from several implementations of the \obs interface. At this point the Rx interface is mainly specialized for hot sources, that do not allow for any form of interaction. Cold sources can be wrapped in this interface as well by simply not interacting with them and only iterating over them as if they had no possibility for interaction.

Even though cold sources do theoretically not belong in the world of a reactive interface, one could argue that these sources are more convenient to work with in the context of a reactive interface. First of all, the Rx interface provides a great way of handling and recovering from errors as well as dealing with completion events. If this had to be done with separate types, such as \code{Try} and \code{Option}, it would be too much of a pain to do so, as monads do not compose greatly. With Rx one can deal with \code{onError} and \code{onCompleted} events and continue continue composing operators after that. Secondly, the Rx interface provides much more operators than similar \itb based interfaces do, allowing for more complex programs to be written in a functional and compositional style. Also the option to schedule work on a different thread or thread pool is a nice addition to the API and removes a lot of boilerplate code (and associated bugs!) that deals with concurrency. Fourth, one can be forced into wrapping an interactive collection in a reactive interface due to the fact that the context (e.g. a constructor or method parameter) requires such an interface. Finally, one could argue that the reactive interface is much more intuitive in regards to the consumption of data and that it is more expressive to use \code{onNext}, \code{onError} and \code{onCompleted} in order to declare what the consumer needs to do with the data it receives.

In practice, one might want to wrap the \code{ResultSet} from a database call into an \obs and schedule it on a different thread in order to not block the applications main thread from the point of sending a query to the database and until the whole \code{ResultSet} is processed. With the query handling on a different thread, the application can for example still process mouse events on the main/ui thread by responding to these events. Notice that in both cases the \obs type is used, even though one \emph{can} pull from a \code{ResultSet} but \emph{cannot} pull from a mouse. Clearly your mouse is NOT a database and therefore they should be treated differently!

Just like the original interface for reactive programming is mostly optimized for wrapping around hot sources, one could imagine an interface for handling cold sources. One could subscribe to this interface, from which point onward this interface would pull data from the cold source on behalf of the subscriber. This would mean a segregation between the purely reactive interface and its implementation of the higher order functions and operators that are applicable to reactive sources on the one hand and the operators that are focused on interactive sources on the other hand.

One could also imagine the backpressure techniques that are currently provided and implemented by Reactive Streams and RxJava to be in this subinterface for interactive sources. This segregation would solve the issue with the Reactive Streams design of its disability to wrap around a reactive source. A drawback of this design, which we already discussed in the previous section, is the fact that a large portion of the operators and higher order function probably need to be reimplemented for this interface.

The segregation of these interfaces would most likely greatly benefit the performance of a library like RxJava. Currently when one uses the RxJava \obs to wrap around a reactive source, it still has to deal with all the backpressure support that is in a large portion of the operators. Some operators like \code{zip} currently even throw exceptions when backpressure support is not explicitly added, for example by operators such as \code{onBackpressureBuffer} and \code{onBackpressureDrop}. This is not a great way of working, as there is no way for the developer to have this issue checked at compile time. Preferably the need of a certain backpressure behavior should be indicated on the type level or at least be silently applied in a default behavior, without bothering the developer with it and causing errors at the unlikeliest of moments (a.k.a. production).

Besides performance, splitting the uses for RxJava's \obs interface into two or more interfaces would also greatly benefit the usability of the whole library. On the one hand, one could have the \textit{reactive} \obs interface, which is suitable for wrapping around hot sources\footnote{this is more or less what the library looked like before verison 0.20} and implements all operators without the use of backpressure. Then on the other hand the library could have the \textit{interactive} \obs interface, which is suitable for wrapping around cold sources. This interface would most likely inherit from the reactive \obs interface, as this interface already contains the contract of the producer being in control.

A third benefit of splitting RxJava's \obs interface is that with multiple interfaces a developer can be more expressive on the language's type level. Currently neither the developer nor the compiler can derive whether an \obs behaves like a cold or a hot stream based on the type of \obs. This would be greatly beneficial, especially in more complex operations for which in some cases operators like \code{publish(selector)} need to be used, whereas in other cases their use is redundant. The compiler and type system being able to determine whether or not these operators are available would also greatly improve the usability.