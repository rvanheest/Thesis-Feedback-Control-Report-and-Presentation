\chapter{An API for feedback control}

While studying the principles of feedback control, we discovered that there are hardly any publicly available libraries or APIs that abstract over the notions of feedback control, allowing us to create and execute feedback systems, both in simulation and in practice. Although surprising at first, this is completely in accordance with the earlier observation that feedback control is not (yet) a commonly used technique in computer science\footnote{Even though we were not able to find existing APIs for this purpose, we would not be surprised if companies turned out to have libraries like this in private.}. Surely, we can write the code ourselves as shown in \cref{sec:imperative-balltracker}, but that isn't really reusable, creates the danger of copy-paste behavior and is more prone to bugs than a dedicated API.

In this chapter we present our own API for creating and executing feedback systems that can potentially be used in production software. \todo{rest of the introduction and layout of this chapter}

\input{4.1-related-work}

\input{4.2-towards-a-feedback-api}































































\clearpage
\begin{itemize}
	\item[\checkmark] Since we do feedback control for computer science, we want to come up with an API to create feedback systems
	\begin{itemize}
		\item[\checkmark] A good API does not yet exist
		\item[\checkmark] Some simple stuff in Python
		\item[\ding{55}] Solution from Peti Koch
	\end{itemize}
	\item Feedback control as ‘working with streams’
	\begin{itemize}
		\item[\checkmark] A component sits in between 2 streams and performs some sort of transformation
		\item[\checkmark] A component is compositional: connecting components, making feedback loop, zipping $\rightarrow$ a feedback system is the same as a component
		\item[\checkmark] Observation: \textbf{a component is the same as a Mealy Machine}
		\item[\checkmark] Derive the exact type of a component, starting from a Mealy Machine and using category theory
		\item[\checkmark] Observation: \textbf{a component is an Arrow}
		\item Introduce the operators on Component
		\begin{itemize}
			\item[\checkmark] Concat
			\item[\checkmark] Lift (as generalizing over all operators)
			\item[\checkmark] Arrow operators (see \LaTeX code)
			\item \textit{$<$many RxMobile operators$>$}
			\item Feedback
		\end{itemize}
		\item Second version of the API
		\begin{itemize}
			\item Subjects and subscriptions are not how you work with the underlying Rx; this is not a real use case for \subj; use \obs and as few times as possible and as late as possible
			\item Function \code{Observable[I] $\Rightarrow$ Observable[O]} as basis
			\item Changes in operators
			\item Observation: this looks like the \textit{Reader Monad} (it's a function), however, it still does not make sense for \comp to be a \textit{Monad}
		\end{itemize}
	\end{itemize}
	\item Ball tracker example with the API
\end{itemize}

\todo{below in chap4 with looking back on chap3?}
The ultimate goal in computer science (especially in software engineering) is to wrap the theory of a piece of technology in some kind of an API, such that anybody can incorperate it easily in their applications, platforms or frameworks. The notion of feedback control is however apparently so foreign to computer science that there does not exist a proper API for this yet. 