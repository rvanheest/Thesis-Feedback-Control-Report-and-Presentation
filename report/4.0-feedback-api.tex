\chapter{An API for feedback control}

While studying the principles of feedback control, we discovered that there wasn't any public library available that abstracts over the notions of feedback control, allows for building feedback systems or execute feedback loops in simulation or production environments. Although surprising at first, this is completely in accordance with the earlier observation that feedback control is not (yet) a commonly used technique in computer science.

Janert describes a small framework for simulating feedback loops \cite{janert2013-feedback}, but that is meanly ment to abstract over the case studies in his book and is far from being usable in practice.

\todo{content here}

\begin{itemize}
	\item Since we do feedback control for computer science, we want to come up with an API to create feedback systems
	\begin{itemize}
		\item A good API does not yet exist
		\item Some simple stuff in Python
		\item Solution from Peti Koch
	\end{itemize}
	\item Introduce the ball tracker as a toy example
	\begin{itemize}
		\item First on 1 dimension; implemented with for-loops etc.
		\item Use this throughout the rest of the Feedback Control section
	\end{itemize}
	\item Feedback control as ‘working with streams’
	\begin{itemize}
		\item A component sits in between 2 streams and performs some sort of transformation
		\item A component is compositional: connecting components, making feedback loop, zipping $\rightarrow$ a feedback system is the same as a component
		\item Observation: \textbf{a component is the same as a Mealy Machine}
		\item Derive the exact type of a component, starting from a Mealy Machine and using category theory
		\item Observation: \textbf{a component is an Arrow}
		\item Introduce the operators on Component
		\begin{itemize}
			\item Arrow operators (see \LaTeX code)
%			\begin{itemize}
%				\item \code{arr :: Arrow a => (b -> c) -> a b c}
%				\item \code{(>>>) :: Arrow a => a b c -> a c d -> a b d}
%				\item \code{first :: Arrow a => a b c -> a (b,d) (c,d)}
%				\item \code{second :: Arrow a => a b c -> a (d,b) (d,c)}
%				\item \code{(***) :: Arrow a => a b c -> a d e -> a (b,d) (c,e)}
%				\item \code{(\&\&\&) :: Arrow a => a b c -> a b d -> a b (c,d)}
%				\item \code{lift2A :: Arrow a => (b -> c -> d) -> a e b ->   a e c -> a e d}
%				\item \code{loop :: Arrow a => a (b,d) (c,d) -> a b c}
%			\end{itemize}
			\item Concat
			\item Zip
			\item Feedback
			\item \textit{$<$many RxMobile operators$>$}
			\item Lift and LiftA2 (as generalizing over all operators)
		\end{itemize}
		\item Ball tracker example with the API
	\end{itemize}
\end{itemize}

\todo{below in chap4 with looking back on chap3?}
The ultimate goal in computer science (especially in software engineering) is to wrap the theory of a piece of technology in some kind of an API, such that anybody can incorperate it easily in their applications, platforms or frameworks. The notion of feedback control is however apparently so foreign to computer science that there does not exist a proper API for this yet. 