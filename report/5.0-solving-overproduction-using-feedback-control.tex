\chapter{Solving overproduction with feedback control}
\label{chap:solving-overproduction}

In \Cref{chap:exploring-the-problem-space} we discussed how streams can originate from various kinds of sources that can be categorized into three groups. We introduced the \textit{hot} source as a strictly reactive collection of data: there is now way to interact with the stream or control how fast it produces its data. On the contrary, a \textit{cold asynchronous} source can be interacted with, as it has an interface from which one can get zero or more elements. However, as the data to be returned can take some time to be computed, this source is still bound to the same notion of time as is the case with the hot source. Finally there is the group of \textit{cold synchronous} sources, which takes away the notion of time: elements that are requested will be returned immediately.

We also discussed several solutions to overproduction in the light of these three groups of sources. We learned that \textit{avoiding} by grouping or dropping data works perfectly for hot and cold asynchronous sources as a first line of defense. \textit{Callstack blocking} on the other hand is something that is automatically done to cold synchronous sources but can potentially be dangerous to hot and cold asynchronous sources as they might form a buffer of calls on the stack. The \textit{Reactive Streams} solution and RxJava's \textit{reactive pull} are to be used on cold sources alone, and cannot work with a hot source as they go against the contract of reactiveness as defined in \cite{berry1991-Reactive}.

The central problem here is that we want a single reactive interface to share between all kinds of data streams. Although one might argue that you ought not to be using a reactive interface for an interactive (cold) source, we acknowledge the fact that in many circumstances it is more practical to view and treat them as `streaming' and `real-time' data rather than having them as interactive sources. In order to do so, we need a way to interact with cold sources in an overproduction-safe way. Reactive Streams and reactive pull achieve this by introducing the concept of backpressure and changing the reactive interface itself, making the consumer in charge, rather than the producer. Not only is this against the concept of reactiveness, it also gives many problems with implementing the operators defined on the reactive interface.

In this chapter we will propose an alternative to backpressure that makes use of the feedback systems described in \Cref{chap:intro-to-feedback-control,chap:feedback-api}. We already concluded that backpressure is not suitable for hot sources, so we will discard these from the discussion in this chapter. The solution proposed here will apply to interactive sources alone.

\input{5.1-buffer-control}

\clearpage
\section*{Content}
\begin{itemize}
	\item[\checkmark] Distinction between hot and cold - we're only considering cold, as hot is not able to handle backpressure
	\item[\checkmark] Bring handling backpressure to the start of the stream
	\item[\checkmark] Feedback control of buffer - general overview of idea + diagram
	\item[\checkmark] Requestable interface
		\begin{itemize}
			\item[\checkmark] request items and let them come down the stream on their own terms (i.e. in a reactive way)
			\item[\checkmark] some implementations of Requestable (iterable collection, Database ResultSet)
		\end{itemize}
	\item[\checkmark] In dept discussion of the feedback system, the metric to be used, the setpoint, etc.
	\item[\checkmark] Implementation of BackpressureObservable
		\begin{itemize}
			\item[\checkmark] feedback system fills the buffer
			\item[\checkmark] reactively pull data from the buffer and send it downstream (exposed as Observable)
		\end{itemize}
	\item[\checkmark] Controller
		\begin{itemize}
			\item[\checkmark] PID control, why it doesn't work here
			\item[\checkmark] relation with Janert
			\item[\checkmark] incremental controller
			\item[$\times$] can we create a chart of the performance of the PID vs incremental controller, similar to Janert?
		\end{itemize}
	\item[\checkmark] Wrapping in an API
	\item How it works in practice
		\begin{itemize}
			\item backpressure examples, but then with the feedback solution
			\item show graphs of how many items get requested each time
		\end{itemize}
	\item Conclusion
\end{itemize}