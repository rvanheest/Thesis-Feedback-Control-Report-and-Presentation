\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Reactive programming is a paradigm in which the program observes events that occur in its environment and reacts to these events as they occur. This is in contrast to the more familiar interactive program flow in which a program \emph{requests} some form of data and only continues the program flow once this data is received. Instead of pulling data in the usual interactive way, reactive programs get data (or events) pushed to them on which they respond according to what is specified. Some of the most common usages of reactive programming can be found in the components of user interfaces (mouse moves, key events or button presses), network communication, results of database queries and clocks or timers. \cite{meijer2012-YMIAD}

In an interactive program, the \textit{consumer} is in charge of requesting the data. The \textit{producer} only has to obey the commands from the consumer and return the requested data. In reactive programs this is the complete opposite: the producer is in charge and sends the data \emph{at its own pace} \cite{berry1991-Reactive}, whereas the consumer has to react to the data it receives from the producer.

This shift in roles between producer and consumer poses an interesting problem: ``\textit{What happens when the consumer cannot keep up with the amount of data that is sent by the producer?}''. In other words, when a consumer has to deal with an overproducing source, how can it handle the excessive amount of data? Several solutions with different policies have already been proposed and implemented in order to solve this problem. We will find that some of these work well under certain circumstances but are not suitable for other kinds of reactive programs. Other solutions change the contract of reactive programming and put the consumer back into command, but still call it `reactive'.

This poses the question whether the concepts behind reactive programming have been generalized too much and whether distinctions between different kinds of reactive programs can lead to a clearer view of what solution works best under which conditions. This thesis will discuss this topic extensively in \autoref{chap:problem-statement} and \autoref{chap:exploring-the-problem-space}.

Based on the conclusions of this first part, we will propose a new solution to the overproduction problem, which makes use of control theory and feedback control systems. This solution can be used as a replacement to solutions that put the consumer back in charge.

Feedback control is a technique that is mainly used in mechanical and electrical engineering, but that is generally overlooked in computer science. One can apply feedback control by continuously measuring a certain property of a system, comparing that to a desired value and alter the system's input based on the error between the desired and measured values. The goal is to ultimately bring the measured property as close to the desired value as possible and keep it as close as possible despite external changes that try to bring the system out of balance \cite{janert2013-feedback}. Practical examples from several fields of engineering are climate control systems, the engine in washing machines, the cruise control system in a car and the reaction control system on a rocket.

Although well suited in several use cases, control theory and the use of feedback systems is generally overlooked in this computer science and software engineering. To the best of our knowledge, there are even no well-written libraries that allow software developers to construct and run feedback systems in a clean way. As we will use feedback control in our solution for the overproduction problem, we will first study the composition of feedback systems and present an small library for this purpose that is based on the concepts of functional and reactive programming. Using this library, we will then propose our solution to the overproduction problem.

\section*{Research Questions}
\addcontentsline{toc}{section}{Research Questions}
This thesis answers a number of questions that are related to reactive programming, overproduction and feedback control, which are listed and briefly introduced in this section.

\subsubsection*{In which ways can a reactive program already be controlled in order to prevent overproduction?}
There are multiple solutions for controlling overproduction in the context of reactive programming. To understand these solutions we first of all need to identify the various types of reactive programs and consider their mutual similarities and differences. This is important since the existing solutions do not work for every type of reactive program.

\subsubsection*{How can we implement a \emph{reactive} feedback system that is composed from smaller parts?} 
As the solution to overproduction that is presented in this thesis makes use of control theory and feedback control, and given that these are not yet widely known and used in computer science, it is important to develop an understanding of these techniques and create the tools necessary to construct feedback systems in an easy way. We will show that these can be seen as reactive programs and implement a library on top of existing reactive programming API's.

\subsubsection*{How can the overproduction problem be reduced to a feedback control problem?}
To solve overproduction using feedback control, it is necessary to get out of the context of reactive programming and abstract this into more general problems that can be solved by control theory. Once we developed this more general problem, we can put it back into the context of reactive programs.

\subsubsection*{Can our solution be integrated in an existing API for reactive programming?}
In order for this solution to be useful in practice it is important to be able to interface with existing API's for reactive programming. To test this, a clean API is needed that does not yet implement any solutions for overproduction. For this purpose we use the newly created RxMobile API \cite{RxMobile}.

\section*{Outline}
\addcontentsline{toc}{section}{Outline}
In the next chapter we will continue this thesis report with a short discussion on the definitions of interactive and reactive programming as it is defined in literature (\autoref{chap:problem-statement}). This is followed up with an extensive introduction to a widely used reactive programming API whose concepts have been implemented in many languages. We will discuss the basic principles of this API as well as it's derivation from interactive programming interfaces. Once these foundations are laid, we will give an overview of the different ways in which it tries to overcome overproduction problems. It is important to first gain a good understanding of reactive programming in general and this API especially, since we will build on top of these in the rest of this thesis.

Different circumstances require different approaches to overproductions, as we already hypothesized above. In \autoref{chap:exploring-the-problem-space} we will explore and categorize these circumstances and describe how overproduction is currently best dealt with in each of these situations. Here we also discuss the current state of abstraction over reactive programming and describe our solution to overproduction and explain for which type of reactive programs we think this will apply.

\todo{add the rest here once it is written...}
